import{aq as A,r as P,a3 as B,l as S,ar as $,N as R,R as z,ak as T,as as F,G as L,a6 as M,q as E,a9 as v,at as H,a5 as U,au as q,h as O,P as N,a1 as G,av as I,aw as K,ax as w,ay as V,az as W,aA as J,a2 as C,W as Q,z as X,O as Y,aB as Z,M as ee,aC as te,I as ae}from"./entry.DwqXwOyw.js";const se=s=>s==="defer"||s===!1;function ne(...s){var D;const o=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(o);let[e,n,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof n!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=T(),c=n,f=()=>null,l=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??f,a.getCachedData=a.getCachedData??l,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??A.deep,a.dedupe=a.dedupe??"cancel";const y=()=>![null,void 0].includes(a.getCachedData(e));if(!t._asyncData[e]||!a.immediate){(D=t.payload._errors)[e]??(D[e]=null);const i=a.deep?P:B;t._asyncData[e]={data:i(a.getCachedData(e)??a.default()),pending:P(!y()),error:S(t.payload._errors,e),status:P("idle")}}const r={...t._asyncData[e]};r.refresh=r.execute=(i={})=>{if(t._asyncDataPromises[e]){if(se(i.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&y())return Promise.resolve(a.getCachedData(e));r.pending.value=!0,r.status.value="pending";const p=new Promise((u,d)=>{try{u(c(t))}catch(b){d(b)}}).then(u=>{if(p.cancelled)return t._asyncDataPromises[e];let d=u;a.transform&&(d=a.transform(u)),a.pick&&(d=oe(d,a.pick)),t.payload.data[e]=d,r.data.value=d,r.error.value=null,r.status.value="success"}).catch(u=>{if(p.cancelled)return t._asyncDataPromises[e];r.error.value=F(u),r.data.value=L(a.default()),r.status.value="error"}).finally(()=>{p.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=p,t._asyncDataPromises[e]};const _=()=>r.refresh({_initial:!0}),k=a.server!==!1&&t.payload.serverRendered;{const i=M();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const u=i._nuxtOnBeforeMountCbs;i&&($(()=>{u.forEach(d=>{d()}),u.splice(0,u.length)}),R(()=>u.splice(0,u.length)))}k&&t.isHydrating&&(r.error.value||y())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(_):a.immediate&&_(),a.watch&&z(a.watch,()=>r.refresh());const p=t.hook("app:data:refresh",async u=>{(!u||u.includes(e))&&await r.refresh()});i&&R(p)}const g=Promise.resolve(t._asyncDataPromises[e]).then(()=>r);return Object.assign(g,r),g}function oe(s,o){const e={};for(const n of o)e[n]=s[n];return e}function re(s,o,e){const[n={},a]=typeof o=="string"?[{},o]:[o,e],t=E(()=>{let m=s;return typeof m=="function"&&(m=m()),v(m)}),c=n.key||H([a,typeof t.value=="string"?t.value:"",...ie(n)]);if(!c||typeof c!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+c);if(!s)throw new Error("[nuxt] [useFetch] request is missing.");const f=c===a?"$f"+c:c;if(!n.baseURL&&typeof t.value=="string"&&t.value[0]==="/"&&t.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:l,lazy:y,default:r,transform:_,pick:k,watch:g,immediate:D,getCachedData:i,deep:p,dedupe:u,...d}=n,b=U({...q,...d,cache:typeof n.cache=="boolean"?void 0:n.cache}),j={server:l,lazy:y,default:r,transform:_,pick:k,immediate:D,getCachedData:i,deep:p,dedupe:u,watch:g===!1?[]:[b,t,...g||[]]};let h;return ne(f,()=>{var x;(x=h==null?void 0:h.abort)==null||x.call(h),h=typeof AbortController<"u"?new AbortController:{};const m=v(n.timeout);return m&&setTimeout(()=>h.abort(),m),(n.$fetch||globalThis.$fetch)(t.value,{signal:h.signal,...b})},j)}function ue(s,o,e){const[n={},a]=typeof o=="string"?[{},o]:[o,e];return re(s,{...n,lazy:!0},a)}function ie(s){var e;const o=[((e=v(s.method))==null?void 0:e.toUpperCase())||"GET",v(s.baseURL)];for(const n of[s.params||s.query]){const a=v(n);if(!a)continue;const t={};for(const[c,f]of Object.entries(a))t[v(c)]=v(f);o.push(t)}return o}const ce=O({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},async setup(s,o){const e=await w[s.name]().then(n=>n.default||n);return()=>C(e,s.layoutProps,o.slots)}}),pe=O({name:"NuxtLayout",inheritAttrs:!1,props:{name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},setup(s,o){const e=T(),n=N(J),a=n===G()?I():n,t=E(()=>{let l=L(s.name)??a.meta.layout??"default";return l&&!(l in w)&&s.fallback&&(l=L(s.fallback)),l}),c=P();o.expose({layoutRef:c});const f=e.deferHydration();if(e.isHydrating){const l=e.hooks.hookOnce("app:error",f);K().beforeEach(l)}return()=>{const l=t.value&&t.value in w,y=a.meta.layoutTransition??V;return W(Q,l&&y,{default:()=>C(Z,{suspensible:!0,onResolve:()=>{Y(f)}},{default:()=>C(le,{layoutProps:X(o.attrs,{ref:c}),key:t.value||void 0,name:t.value,shouldProvide:!s.name,hasTransition:!!y},o.slots)})}).default()}}}),le=O({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean}},setup(s,o){const e=s.name;return s.shouldProvide&&ee(te,{isCurrent:n=>e===(n.meta.layout??"default")}),()=>{var n,a;return!e||typeof e=="string"&&!(e in w)?(a=(n=o.slots).default)==null?void 0:a.call(n):C(ce,{key:e,layoutProps:s.layoutProps,name:e},o.slots)}}}),he=async(s,o="GET",e={})=>{var f,l;const{data:n,pending:a,error:t,refresh:c}=await ue(s,{...e,method:o,baseURL:"http://localhost:3333"},"$sC22i8rhLA");return(f=t.value)!=null&&f.data.errors&&ae(`Erreur: ${t.value.statusCode} - ${t.value.statusMessage}`,(l=t==null?void 0:t.value)==null?void 0:l.data.errors.map(y=>y.message),"error"),{data:n,pending:a,error:t,refresh:c}};export{pe as _,he as u};
